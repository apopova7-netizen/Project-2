//
// Created by Lenovo on 20.01.2026.
//

#ifndef PROJECT_2_STUDENT1_H
#define PROJECT_2_STUDENT1_H

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

inline void Swap(int* a1, int* a2);
inline void Reverse(int arr[], int start, int end);
inline void Sorting(int* arr, int n);
inline void PrintPermutation(int perm[], int n);

inline bool NextPermutationNarayana(int arr[], int n);
inline bool PrevPermutationNarayana(int arr[], int n);

inline void PermutationNarayana(int arr[], int n,
                          void (*callback)(int perm[], int n));
inline void PermutationReverseNarayana(int arr[], int n,
                          void (*callback)(int perm[], int n));

inline bool ChooseStepPermutationNarayana(int arr[], int n, int direction);
inline void ChoosePermutationNarayana(int arr[], int n,
                          void (*callback)(int perm[], int n), int direction);


inline long Factorial(int n);
inline void PermutationFromIndex(int arr[], int n,
                        long index, int result[]);
inline void PermutationsFactorialSystem(int arr[],
        int n,void (*callback)(int perm[], int n));






#endif //PROJECT_2_STUDENT1_H

void Swap(int* a1, int* a2) {
    int tmp = *a1;
    *a1 = *a2;
    *a2 = tmp;
}
void Sorting(int* arr, int n){

    for (int i = 0; i < n - 1; i++)
        for (int j = 0; j < n - i - 1; j++) {
            if (*(arr + j) > *(arr + j + 1))
                Swap(arr + j, arr + j + 1);
        }
}

void Reverse(int arr[], int start, int end) {
    while (start < end) {
        int tmp = arr[start];
        arr[start] = arr[end];
        arr[end] = tmp;

        start++;
        end--;
    }
}

bool NextPermutationNarayana(int arr[], int n) {

    if (n <= 1)
        return false;

    int i = n - 2;
    while (i >= 0 && arr[i] >= arr[i+1])
        i--;

    if (i < 0)
        return false;

    int j = n - 1;
    while (arr[j] <= arr[i])
        j--;

    Swap(&arr[i],&arr[j]);

    Reverse(arr, i + 1, n - 1);

    return true;
}
bool PrevPermutationNarayana(int arr[], int n) {

    if (n <= 1)
        return false;

    int i = n - 2;
    while (i >= 0 && arr[i] <= arr[i+1])
        i--;

    if (i < 0)
        return false;

    int j = n - 1;
    while (arr[j] >= arr[i])
        j--;

    Swap(&arr[i],&arr[j]);

    Reverse(arr, i + 1, n - 1);

    return true;
}

void PrintPermutation(int perm[], int n) {
    for (int i = 0; i < n; i++)
        printf("%d", perm[i]);
    puts("");
}

void PermutationNarayana(int arr[], int n,
                          void (*callback)(int perm[], int n)) {

    int* copy = (int*)malloc(sizeof(int) * n);
    memcpy(copy, arr, sizeof(int) * n);

    Sorting(copy,n);

    callback(copy, n);
    while (NextPermutationNarayana(copy,n))
        callback(copy,n);

    free(copy);
}

void PermutationReverseNarayana(int arr[], int n,
                          void (*callback)(int perm[], int n)) {

    int* copy = (int*)malloc(sizeof(int) * n);
    memcpy(copy, arr, sizeof(int) * n);

    Sorting(copy,n);
    Reverse(copy,0,n - 1);

    callback(copy, n);
    while (PrevPermutationNarayana(copy,n))
        callback(copy,n);

    free(copy);
}
bool ChooseStepPermutationNarayana(int arr[], int n, int direction) {

    if (n <= 1)
        return false;

    int i = n - 2;

    if (direction)
        while (i >= 0 && arr[i] >= arr[i+1])
            i--;
    else
        while (i >= 0 && arr[i] <= arr[i+1])
            i--;


    if (i < 0)
        return false;

    int j = n - 1;

    if (direction)
        while (arr[j] <= arr[i])
            j--;
    else
        while (arr[j] >= arr[i])
            j--;


    Swap(&arr[i],&arr[j]);

    Reverse(arr, i + 1, n - 1);

    return true;
}

void ChoosePermutationNarayana(int arr[], int n,
                          void (*callback)(int perm[], int n), int direction){

    int* copy = (int*)malloc(sizeof(int) * n);
    memcpy(copy, arr, sizeof(int) * n);

    Sorting(copy,n);

    if (!direction)
        Reverse(copy,0,n - 1);

    callback(copy, n);


    while (ChooseStepPermutationNarayana(copy,n,direction))
        callback(copy,n);

    free(copy);
}

 long Factorial(int n){
    long result = 1;

    for (int i = 2; i <= n; i++)
        result *= i;
    return result;
}


void PermutationFromIndex(int arr[], int n, long index, int result[]) {

    if (n == 0)
        return;
    long totalPerm = Factorial(n);
    index = (index % totalPerm + totalPerm) % totalPerm;

    int* facDigits = (int*)malloc(n * sizeof(int));
    long tmp = index;

    for (int i = 1; i <= n; i++) {
        int div = Factorial(n - i);
        *(facDigits + i - 1) = tmp / div;
        tmp %= div;
    }

    int* copy = (int*)malloc(sizeof(int) * n);
    memcpy(copy, arr, sizeof(int) * n);
    int realLen = n;

    for (int i = 0; i < n; i++) {
        int takeInd = *(facDigits + i);
        result[i] = copy[takeInd];

        for (int j = takeInd; j < realLen - 1; j++)
            copy[j] = copy[j+1];
        copy[realLen - 1] = 0;

        realLen--;
    }
free(facDigits);
free(copy);
}

void PermutationsFactorialSystem(int arr[], int n,
                                  void (*callback)(int perm[], int n)) {
    if (n <= 0)
        return;

    long totalPerm = Factorial(n);
    int* perm = (int*)malloc(n * sizeof(int));

    for (long ind = 0; ind < totalPerm; ind++) {
        PermutationFromIndex(arr,n,ind,perm);
        callback(perm,n);
    }
}

/**
 * ЗАДАЧА 2.3: Алгоритм через таблицу инверсий
 *
 * TODO:
 * 1. Реализовать преобразование перестановка ↔ таблица инверсий
 * 2. Генерировать все возможные таблицы инверсий
 * 3. Конвертировать каждую таблицу в перестановку
 * 4. Гарантировать лексикографический порядок
 */
int NextInversionTable(int inv[], int n) {
    for (int i = 0; i < n; i++)
        return 1;
}

void PermutationFromInversionTable(int inv_table[], int n, int arr[],int result[]) {
    // TODO: Алгоритм построения перестановки по таблице инверсий
    // TODO: Использовать структуры данных для эффективной вставки
    // TODO: Проверка корректности таблицы инверсий
}

void PermutationsInversionTable(int arr[], int n,
                                 void (*callback)(int perm[], int n)) {
    // TODO: Генерация всех возможных таблиц инверсий
    // TODO: Для каждой таблицы - построение перестановки
    // TODO: Вызов callback() с результатом
    // TODO: Сортировка исходного массива для согласованности
}

/**
 * ЗАДАЧА 2.4: Алгоритм "Плюс-один" (инкрементальный)
 *
 * TODO:
 * 1. Использовать массив индексов [0,1,2,...,n-1]
 * 2. Инкрементально изменять индексы как числа в смешанной системе счисления
 * 3. Преобразовывать индексы в перестановки
 * 4. Гарантировать генерацию всех перестановок
 */
void permutations_plus_one(int arr[], int n,
                          void (*callback)(int perm[], int n)) {
    // TODO: Инициализация массива индексов
    // TODO: Цикл генерации всех комбинаций индексов
    // TODO: Преобразование индексов в перестановку исходного массива
    // TODO: Вызов callback() для каждой перестановки
}

